
filter {
	grok {
		
		pattern_definitions => {
			"HTTPVERSION" => "HTTP(/|\s)%{NUMBER}"
			"HTTPDATE" => "%{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME}((\s%{ISO8601_TIMEZONE})?)"
		}

		# Using ECS-Fieldnames from: https://www.elastic.co/guide/en/ecs/current/index.html
		# Use [field][nested_field] to apply dotted notation (https://discuss.elastic.co/t/logstash-grok-patterns-with-ecs/197871/11) 
		match => {"message" => "%{IPORHOST:[client][address]} %{USERNAME:[user][ident]} %{USERNAME:[user][name]} \[%{HTTPDATE:timestamp}\] \"%{WORD:[http][request][method]} %{NOTSPACE:[url][original]} %{HTTPVERSION:[http][version]}\" %{INT:[http][response][status_code]} %{INT:[http][response][bytes]} \"%{DATA:[http][request][referrer]}\" \"%{DATA:[user_agent][original]}\""}
	}
	
	mutate {
		copy => {"[client][address]" => "[client][ip]"}
	}

	date {
		match => ["timestamp", "dd/MMM/yyyy:HH:mm:ss"]
	}

	geoip {
		source => "[client][ip]"
	}

	translate {
		field => "[http][response][status_code]"
		destination => "[http][response][status_code_desc]"
		# filed-based lookups, using dictonary_path, are also supported for yaml, json and csv
		dictionary => {
			"200" => "OK"
			"404" => "Not Found"
			"500" => "Internal Server Error"
		}
		fallback => "n/a"
	}
}
